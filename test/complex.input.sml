val x : (int,string) Either.either =
  case (a ^ "hi"; 0) of
    0 => 0 | 1373205 => x
  | _ => (f x) handle Foo => y | _ => z

val y = fn x => x
val z = { a = 1 + 2 : string, b =

  Foo "hi" #"x",         c = List.map (fn x => Fn.id x + 1), stuff = [1,2,f [#1 o #foo bar, 3]]
, things = raise Fail (#2 "wow") x before print "hi"}


val res = if foo x then bar y else raise oh no "!"

val _ = 2 + (while true do print "hi")

val SOME ({x=x,y=foo,...} :: xs) = something

val s = case foo of (1 | 2) => "small" | _ => "big"

structure S1 = struct end

  structure S2 = let val x = 1 in S1 end
structure S3 = MkFoo (S2)
and S5 = struct
val (x,y) = {1=3,2= f "hi" o #foo} and w = 4 val z = 3 end

val rec f :int*bool = fn () => let in foo () end

fun fact (0 : int) : int = 1
  | fact n = n * fact (n - 1)

type t = int and ('a,'b) foo = 'a option

infixr 5 |> <|>
infix |||


local open Int String in type t = int

end datatype foo = Foo | Bar of int | Baz | More of t * int | Qux of string * (int * bool)
and bar = Bar of foo * string * foo
withtype t = foo * foo
and u = int
and v = u

datatype foo' =
datatype foo

functor Foo (X : BOOL) = struct end
and Bar (val x : int) :> INTEGER = Foo (Bool)
and Baz (X : sig val x : int and y : string end) = Bar (X)

abstype foo = Foo | Bar and bar = Baz | Qux withtype t = int and u = bool with val x = Foo end

type u = {}
and v = {x:int, y:int * string}
